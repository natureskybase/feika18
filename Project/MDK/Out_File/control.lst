C251 COMPILER V5.60.0,  control                                                            06/05/23  18:04:43  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE control
OBJECT MODULE PLACED IN .\Out_File\control.obj
COMPILER INVOKED BY: D:\Keil_v5\C251\BIN\C251.EXE ..\CODE\control.c XSMALL INTR2 WARNINGLEVEL(3) BROWSE INCDIR(..\..\Lib
                    -raries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE;..\USER\inc;..\USER\src)
                    - DEBUG PRINT(.\Out_File\control.lst) TABS(2) OBJECT(.\Out_File\control.obj) 

stmt  level    source

    1          #include "control.h"
    2          #include "math.h"
    3          #include "pid.h"
    4          
    5          
    6          akeman_t akeman_left ;    // 结构体变量，记录脉冲，实际速度，目标速度
    7          akeman_t akeman_right;
    8          uint8 pid_flag=0;         // 电机闭环开启标志
    9          float order_angle=0;      // 目标角度
   10          float order_speed=0;      // 目标速度
   11          float adc_err=0;         // 电感误差
   12          float adc_err_array[5];  // 窗口电感误差
   13          int16 window_flag=1;     // 窗口标志位
   14          
   15          int16 Roundabout_flag_L=0; // 左环岛检测标志位
   16          int16 Roundabout_flag_R=0; // 右环岛检测标志位
   17          int16 Roundabout_count=0;  // 环岛打死中断次数
   18          
   19          float ADC_error_a=0;     // 电感误差加速度(ms)
   20          int16 lostline_flag;     // 丢线标志
   21          int16 lostline_dir;      // 左,右丢线标志
   22          int16 Dir_judge_flag;    // 位置检测标志位
   23          
   24          
   25          enum Car_State      // 用于表示小车当前状态
   26          {
   27            Straight = 0,
   28            Turn_Left,
   29            Turn_Right,
   30            Round,    // 环岛
   31            Slope,    // 斜坡
   32          };
   33          
   34          int countADC = 0;
   35          float Adc_Five_Del_1 = 0, Adc_Five_Del_2 = 0, Adc_Five_Del_3 = 0, Adc_Five_Del_4 = 0;
   36          float Adc_Five_Mean_1_Las = 0, Adc_Five_Mean_2_Las = 0, Adc_Five_Mean_3_Las = 0, Adc_Five_Mean_4_Las = 0;
   37          float Dev_errs[8] = {0, 0, 0, 0, 0, 0, 0, 0};   // 偏心率误差判断
   38          int16 dev_flag = 0;      // 窗口标志位
   39          
   40          /**************************************************************************
   41          函数功能：舵机角度和电机速度的协同控制
   42          输入参数：小车基准速度（单位：mm/s），舵机角度（单位：°）
   43          **************************************************************************/
   44          void Akeman_Control(float basic_speed,float target_angle)
   45          {
   46   1        float akeman_diff;  //左右轮相对basic_speed的差速
   47   1        
   48   1        /****读取编码器数值****/
   49   1        Encoder_Read();
   50   1        Encoder_Clear();
   51   1        
   52   1        /****计算两电机实际转速****/
   53   1        //编码器是1024线，4倍频，齿数为30
   54   1        //车轮直径56mm，与编码器对应齿数为68
   55   1        akeman_left.current_speed  = pulse_left *0.20603922;
   56   1        akeman_right.current_speed = pulse_right*0.20603922;
   57   1        
C251 COMPILER V5.60.0,  control                                                            06/05/23  18:04:43  PAGE 2   

   58   1        /****计算两电机目标转速****/
   59   1        akeman_diff = basic_speed*(14.2*tan(target_angle*3.14/180.0))/20.0; //相对差速
   60   1        akeman_left.target_speed  = basic_speed - akeman_diff;
   61   1        akeman_right.target_speed = basic_speed + akeman_diff;
   62   1        
   63   1        /****PID开启时控制电机和舵机****/
   64   1        if(pid_flag)
   65   1        {
   66   2          /****电机闭环****/
   67   2          Motor_PID_Control(akeman_left.current_speed ,akeman_left.target_speed ,akeman_right.current_speed ,akem
             -an_right.target_speed);
   68   2          
   69   2          /****舵机转角****/
   70   2          Steer_Spin(target_angle);
   71   2        }
   72   1      }
   73          
   74          
   75          /**************************************************************************
   76          函数功能：电机PID闭环控制
   77          输入参数：左右轮的实际与目标转速
   78          **************************************************************************/
   79          void Motor_PID_Control(float current_l,float target_l,float current_r,float target_r)
   80          {
   81   1        static float pwm_l=0;
   82   1        static float pwm_r=0; 
   83   1        
   84   1        
   85   1      //  static float pwm_l=0,error_l=0,last_error_l=0,prev_error_l=0;
   86   1      //  static float pwm_r=0,error_r=0,last_error_r=0,prev_error_r=0;
   87   1      //  float kp_l=akeman_left.kp ,ki_l=akeman_left.ki ,kd_l=akeman_left.kd ;
   88   1      //  float kp_r=akeman_right.kp,ki_r=akeman_right.ki,kd_r=akeman_right.kd;
   89   1      //  
   90   1      //  /****计算本次偏差****/
   91   1      //  error_l = target_l - current_l;
   92   1      //  error_r = target_r - current_r;
   93   1      //  
   94   1      //  /****若实际速度为0，则不加积分项****/
   95   1      //  if(current_l==0) ki_l=0;
   96   1      //  if(current_r==0) ki_r=0;
   97   1      //  
   98   1      //  /****增量式PID控制器****/
   99   1      //  pwm_l += (int32)(kp_l*(error_l-last_error_l) + ki_l*error_l + kd_l*(error_l-2*last_error_l+prev_error_
             -l))*100;
  100   1      //  pwm_r += (int32)(kp_r*(error_r-last_error_r) + ki_r*error_r + kd_r*(error_r-2*last_error_r+prev_error_
             -r))*100;
  101   1      //  
  102   1      //  /****限幅****/
  103   1      //  if(pwm_l >  PWM_DUTY_MAX) pwm_l =  PWM_DUTY_MAX;
  104   1      //  if(pwm_l < -PWM_DUTY_MAX) pwm_l = -PWM_DUTY_MAX;
  105   1      //  if(pwm_r >  PWM_DUTY_MAX) pwm_r =  PWM_DUTY_MAX;
  106   1      //  if(pwm_r < -PWM_DUTY_MAX) pwm_r = -PWM_DUTY_MAX;
  107   1      //  
  108   1      //  /****保存前两次偏差****/
  109   1      //  prev_error_l = last_error_l;
  110   1      //  prev_error_r = last_error_r;
  111   1      //  last_error_l = error_l;
  112   1      //  last_error_r = error_r;
  113   1      
  114   1        pwm_l=pid_calc(&pid_left_,current_l,target_l);
  115   1        pwm_r=pid_calc(&pid_right_,current_r,target_r); 
  116   1        Motor_Control((int32)pwm_l,(int32)pwm_r);
  117   1      }
  118          
  119          
  120          /**************************************************************************
C251 COMPILER V5.60.0,  control                                                            06/05/23  18:04:43  PAGE 3   

  121          函数功能：电感差比和归一化运算
  122          输入参数：A,B为差比和权重
  123          **************************************************************************/
  124          float ADC_error_processing(float A,float B,float compensation)
  125          {
  126   1      //  考虑电感值误差处理
  127   1      //  adc_err = (1/1.0*adc1-1/1.0*adc4)/(1/1.0*adc1+1/1.0*adc4);
  128   1      //  adc_err = (adc4 - adc1)/10;
  129   1        adc_err = (A*(adc1-adc4)/(float)(adc1+adc4))+(B*(adc2-adc3)/(float)(adc2+adc3))+compensation/100;
  130   1        return adc_err;
  131   1      }
  132          
  133          
  134          /**************************************************************************
  135          函数功能：一阶低通滤波
  136          输入参数：无
  137          **************************************************************************/
  138          float ADC_error_weight_filtering(void)
  139          {
  140   1        static float adc_err_last = 0;
  141   1        adc_err = (0.8)*adc_err+(0.2)*adc_err_last;
  142   1        adc_err_last = adc_err;
  143   1        
  144   1        return adc_err;
  145   1      }
  146          
  147          
  148          /**************************************************************************
  149          函数功能：窗口滤波
  150          输入参数：窗口数组
  151          **************************************************************************/
  152          float ADC_error_window_filtering(void)
  153          {
  154   1        adc_err_array[window_flag]=adc_err;
  155   1        
  156   1        window_flag ++;
  157   1        
  158   1        if(window_flag==5)
  159   1          window_flag=0;
  160   1        
  161   1        
  162   1        if(adc_err_array[0]!=0)
  163   1          adc_err=(adc_err_array[1]+adc_err_array[2]+adc_err_array[3]+adc_err_array[4])/4;
  164   1        
  165   1        
  166   1        return adc_err;
  167   1      }
  168          
  169          
  170          /**************************************************************************
  171          函数功能：窗口滤波2
  172          输入参数：窗口数组
  173          **************************************************************************/
  174          float Dev_Err_Window_Filter_2(void)
  175          {
  176   1        float sum = 0;
  177   1        int i =0;
  178   1        
  179   1        Dev_errs[dev_flag] = adc_err;
  180   1        dev_flag ++;
  181   1        
  182   1        if(dev_flag==8)
  183   1          window_flag=0;
  184   1        
  185   1        
  186   1        if(Dev_errs[0]==0)
C251 COMPILER V5.60.0,  control                                                            06/05/23  18:04:43  PAGE 4   

  187   1        {
  188   2          for(i = 0; i< 8; i++)
  189   2          {
  190   3            Dev_errs[i] = adc_err;
  191   3          }
  192   2        }
  193   1        
  194   1        for(i = 0; i< 8; i++)
  195   1        {
  196   2          sum += Dev_errs[i];
  197   2        }
  198   1        
  199   1        adc_err = sum / 8;
  200   1        
  201   1        
  202   1        return adc_err;
  203   1      }
  204          
  205          /**************************************************************************
  206          函数功能：ADC_Err的变化趋势
  207          
  208          函数操作：
  209                    判定ADC_Err目前处于什么变化趋势
  210                    求相关系数
  211          
  212          
  213          输入参数：无
  214          **************************************************************************/
  215          float ADC_Err_Trendency(void)
  216          {
  217   1        float Up1 = 0, Down1 = 0, DownX1 = 0, DownY1 = 0;
  218   1        float Up2 = 0, Down2 = 0, DownX2 = 0, DownY2 = 0;
  219   1        float R1, R2;
  220   1        int i = 0;
  221   1        
  222   1        // 先求出 X，Y的平均值
  223   1        float X_Mean = 4.5, Y_Mean_1 = 0, Y_Mean_2 = 0;
  224   1      
  225   1        for(;i < 8; i++)
  226   1        {
  227   2          Y_Mean_1 += Dev_errs[i];
  228   2        }
  229   1        Y_Mean_1 /= 8;
  230   1      
  231   1        
  232   1        // 回归系数R：求分子
  233   1        for(i = 0;i < 8; i++)
  234   1        { 
  235   2          // (Xi - X_Mean) * (Yi - Y_Mean)
  236   2          Up1 += ((i + 1) - 4.5) * ( Dev_errs[i] - Y_Mean_1 );
  237   2        }
  238   1        
  239   1        // 回归系数R：求分母
  240   1        for(i = 0;i < 8; i++)
  241   1        { 
  242   2          //  (Xi - X_Mean) * (Xi - X_Mean)
  243   2          //  (Yi - Y_Mean) * (Yi - Y_Mean)
  244   2          DownX1 += ((i + 1) - 4.5) * ((i + 1) - 4.5);
  245   2          DownY1 += ( Dev_errs[i] - Y_Mean_1 ) * ( Dev_errs[i] - Y_Mean_1 );
  246   2        }
  247   1        DownX1 = sqrt(DownX1);
  248   1        DownY1 = sqrt(DownY1);
  249   1        Down1 = DownX1 * DownY1;
  250   1        
  251   1        R1 = Up1 / Down1;
  252   1        
C251 COMPILER V5.60.0,  control                                                            06/05/23  18:04:43  PAGE 5   

  253   1        /*          求二次型的回归系数      */
  254   1        
  255   1        
  256   1        for(i=0 ;i < 8; i++)
  257   1        {
  258   2          Y_Mean_2 += sqrt(Dev_errs[i]);
  259   2        }
  260   1        Y_Mean_2 /= 8;
  261   1      
  262   1        
  263   1        // 回归系数R：求分子
  264   1        for(i = 0;i < 8; i++)
  265   1        { 
  266   2          // (Xi - X_Mean) * (Yi - Y_Mean)
  267   2          Up2 += ((i + 1) - 4.5) * ( sqrt(Dev_errs[i]) - Y_Mean_2 );
  268   2        }
  269   1        
  270   1        // 回归系数R：求分母
  271   1        for(i = 0;i < 8; i++)
  272   1        { 
  273   2          //  (Xi - X_Mean) * (Xi - X_Mean)
  274   2          //  (Yi - Y_Mean) * (Yi - Y_Mean)
  275   2          DownX2 += ((i + 1) - 4.5) * ((i + 1) - 4.5);
  276   2          DownY2 += ( sqrt(Dev_errs[i]) - Y_Mean_2 ) * ( sqrt(Dev_errs[i]) - Y_Mean_2 );
  277   2        }
  278   1        
  279   1        DownX2 = sqrt(DownX2);
  280   1        DownY2 = sqrt(DownY2);
  281   1        Down2 = DownX2 * DownY2;
  282   1        
  283   1        R2 = Up2 / Down2;
  284   1        
  285   1        if(fabs(R1) > fabs(R2))   return 0; // 线性
  286   1        else if (R2 < 0)          return 1; // 左二次性
  287   1        else                      return 2; // 右二次性
  288   1      }
  289          
  290          
  291          
  292          /**************************************************************************
  293          函数功能：轨道状态检测
  294          输入参数：无
  295          **************************************************************************/
  296          int16 Direct_judge(void)
  297          {
  298   1         static int16 res = 0;  // 小车当运行位置:0表示直道 
  299   1        
  300   1        //  阈值判断方向 //
  301   1        if(adc_err >= -0.29 && adc_err <= 0.29)
  302   1        res = 0;        // 直道
  303   1        
  304   1        if(res == 0 && res != 2 && adc_err >= 0.29)
  305   1        res = 1;        // 左转弯
  306   1        
  307   1        if(res == 0 && res != 1 && adc_err <= -0.29)
  308   1        res = 2;        // 右转弯
  309   1        
  310   1        // 环岛检测 //
  311   1        if(adc1>3900 && adc2 >3900)
  312   1        {
  313   2          delay_ms(10);
  314   2          if(adc3 < 3900 && adc4 < 3900)
  315   2          res = 3;    // 左环岛入环
  316   2          Roundabout_flag_L = 1;
  317   2        }
  318   1        if(adc3>3900 && adc4 >3900)
C251 COMPILER V5.60.0,  control                                                            06/05/23  18:04:43  PAGE 6   

  319   1        {
  320   2          delay_ms(10);
  321   2          if(adc1 < 3900 && adc2 < 3900)
  322   2          res = 4;    // 右环岛入环
  323   2          Roundabout_flag_R = 1;
  324   2        }
  325   1        
  326   1        // 过渡状态的判断 //
  327   1        if(adc_err >= 0.6 && adc4 <= 500)
  328   1        res = 8;        //左转弯过渡状态
  329   1        
  330   1        else if(adc_err <= -0.6 && adc1 <= 500)
  331   1        res = 9;        //右转弯过渡状态
  332   1        
  333   1        return res;
  334   1      }
  335          
  336          
  337          /**************************************************************************
  338          函数功能：轨道状态检测(Version 2)
  339          输入参数：无
  340          **************************************************************************/
  341          int16 Direct_judge_Accele(void)
  342          {
  343   1         static enum Car_State state = Straight;  // 小车状态：默认直行
  344   1        
  345   1        /*    直线的判定：
  346   1                        偏心率一般会很小
  347   1                        若有偏移现象，一般是由车体不正造成， 偏心率将线性变化
  348   1        */
  349   1        
  350   1        if( fabs(adc_err) < 0.2 && ADC_Err_Trendency() == 0)//if( fabs(adc_err) < 0.2 && ADC_Err_Trendency(1.2) 
             -== 0)
  351   1        {
  352   2          state = Straight;
  353   2        }
  354   1        
  355   1        /*    环岛的判定：
  356   1                        偏心率一般显著比直线大
  357   1                        所有电感都在增大
  358   1        */
  359   1        if( fabs(adc_err) > 0.2 && Adc_Five_Del_1 > 0 && Adc_Five_Del_2 > 0 && Adc_Five_Del_3 > 0 && Adc_Five_De
             -l_4 > 0)
  360   1        {
  361   2          state = Round;
  362   2        }
  363   1        
  364   1        
  365   1        /*    进入转弯的判定：
  366   1                        车当前仍在直行
  367   1                        偏心率一般会比直线明显偏大
  368   1                        偏心率将二次变化（x方 + y方 = R方）
  369   1        */
  370   1        
  371   1        if( adc_err < -0.2 && ADC_Err_Trendency() == 1 && state == Straight)
  372   1        {
  373   2          state = Turn_Left;
  374   2        }
  375   1        if( adc_err > 0.2 && ADC_Err_Trendency() == 2 && state == Straight)
  376   1        {
  377   2          state = Turn_Right;
  378   2        }
  379   1        
  380   1        
  381   1        /*    离开转弯的判定：
  382   1                        车当前仍在弯道
C251 COMPILER V5.60.0,  control                                                            06/05/23  18:04:43  PAGE 7   

  383   1                        偏心率将二次变化（x方 + y方 = R方）
  384   1                        偏心率变化方向与当前转弯方向相反
  385   1        */
  386   1        
  387   1        if( fabs(adc_err) < 0.2 && ADC_Err_Trendency() == 2 && state == Turn_Left)
  388   1        {
  389   2          state = Straight;
  390   2        }
  391   1        if( fabs(adc_err) < 0.2 && ADC_Err_Trendency() == 1 && state == Turn_Right)
  392   1        {
  393   2          state = Straight;
  394   2        }
  395   1        
  396   1        
  397   1        return state;
  398   1      }
  399          
  400          
  401          
  402          
  403          /**************************************************************************
  404          函数功能：丢线判断
  405          输入参数：无
  406          **************************************************************************/
  407          void lost_line_judge(void)
  408          {
  409   1        int8 i,L_count=0,R_count=0;// 左右计数
  410   1        lostline_dir = 0;   
  411   1        if(lostline_flag==0)//丢线标志为0时进入
  412   1        {
  413   2          if(adc1 < 2000 && adc2 < 2000 && adc3 < 2000 && adc4 < 2000) //进入丢线条件
  414   2            lostline_flag=1;//丢线标志置1
  415   2      
  416   2          for(i=0;i<5;i++)//奇数
  417   2          {
  418   3            if(adc_err_array[i]<0)
  419   3             R_count++;
  420   3            if(adc_err_array[i]>0)
  421   3             L_count++;
  422   3          }
  423   2          if(L_count>R_count)
  424   2            lostline_dir=1;//左丢线标志
  425   2          if(L_count<R_count) 
  426   2            lostline_dir=2;//右丢线标志
  427   2      
  428   2        }
  429   1      }
  430          
  431          
  432          /**************************************************************************
  433          函数功能：丢线处理
  434          输入参数：无
  435          **************************************************************************/
  436          void lostline_deal(void)
  437          {
  438   1      
  439   1        if(lostline_flag==1)
  440   1          {
  441   2            if(lostline_dir==1)//左丢线
  442   2              order_angle = -100;
  443   2            
  444   2            if(lostline_dir==2)//右丢线
  445   2              order_angle = 100;
  446   2      
  447   2            if(adc1 > 2000 && adc2 > 2000 && adc3 > 2000 && adc4 > 2000)
  448   2              lostline_flag=0;
C251 COMPILER V5.60.0,  control                                                            06/05/23  18:04:43  PAGE 8   

  449   2          }
  450   1      }
  451          
  452          
  453          /**************************************************************************
  454          函数功能：根据adc读值修正角度(舵机传统pid算法)
  455          输入参数：PID控制参数
  456          **************************************************************************/
  457          float Correct_Angle(float kp,float kd,float ki)
  458          {
  459   1        float target_angle;
  460   1        float target_angle_last;
  461   1        static float adc_err_last = 0;
  462   1        static float integral_err = 0;
  463   1        
  464   1      //  pd控制方案
  465   1      //  target_angle = kp*adc_err + kd*(adc_err-adc_err_last);
  466   1      //  kp+=adc_err*adc_err*0.1;//加入动态变化
  467   1        
  468   1      //  pid控制方案
  469   1        target_angle = kp*adc_err + kd*(adc_err-adc_err_last)+(integral_err+=ki*adc_err);
  470   1        target_angle=0.8*target_angle+0.2*target_angle_last;
  471   1        target_angle_last=target_angle;
  472   1        
  473   1        adc_err_last = adc_err;
  474   1        
  475   1        return target_angle;
  476   1      }
  477          
  478          /**************************************************************************
  479          函数功能：开启电机闭环
  480          **************************************************************************/
  481          void PID_on(void)
  482          {
  483   1        pid_flag = 1;
  484   1      }
  485          
  486          
  487          /**************************************************************************
  488          函数功能：关闭电机闭环
  489          **************************************************************************/
  490          void PID_off(void)
  491          {
  492   1        pid_flag = 0;
  493   1      }
*** WARNING C183 IN LINE 217 OF ..\CODE\control.c: dead assignment eliminated
*** WARNING C183 IN LINE 218 OF ..\CODE\control.c: dead assignment eliminated
*** WARNING C183 IN LINE 223 OF ..\CODE\control.c: dead assignment eliminated
*** WARNING C184 IN LINE 470 OF ..\CODE\control.c: value of 'target_angle_last' possibly undefined


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      2254     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       183         54
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
C251 COMPILER V5.60.0,  control                                                            06/05/23  18:04:43  PAGE 9   

  const size           =    ------     ------
  hconst size          =       225     ------
End of Module Information.


C251 COMPILATION COMPLETE.  4 WARNING(S),  0 ERROR(S)
